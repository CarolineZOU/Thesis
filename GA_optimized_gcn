import numpy as np
import pandas as pd
import torch
import torch.nn as nn
import torch.optim as optim
from torch_geometric.data import Data
from torch_geometric.nn import GCNConv
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error, r2_score
import matplotlib.pyplot as plt
import os
import matplotlib.dates as mdates
from datetime import datetime
import random

plt.rcParams['font.sans-serif'] = ['SimHei']
plt.rcParams['axes.unicode_minus'] = False


def smape(y_true, y_pred):
    denominator = (np.abs(y_true) + np.abs(y_pred)) / 2
    diff = np.abs(y_true - y_pred) / (denominator + 1e-6)
    return 100 * np.mean(diff)


def load_and_preprocess(filepath):
    try:
        df = pd.read_excel(filepath, engine='openpyxl')
        required_cols = ['date', 'T_AQI', 'B_AQI', 'S_AQI']
        missing_cols = [col for col in required_cols if col not in df.columns]
        if missing_cols:
            raise ValueError(f"缺少必要列: {missing_cols}")

        df['date'] = pd.to_datetime(df['date'], format='%Y%m%d', errors='coerce')
        if df['date'].isnull().any():
            raise ValueError("日期格式不正确")

        start_date = '20200101'
        end_date = '20231231'
        mask = (df['date'] >= pd.Timestamp(start_date)) & (df['date'] <= pd.Timestamp(end_date))
        df = df.loc[mask]

        exclude_suffixes = ['AQI']
        feature_cols = []
        for prefix in ['T_', 'B_', 'S_']:
            feature_cols += [
                col for col in df.columns
                if col.startswith(prefix) and not any(col.endswith(suffix) for suffix in exclude_suffixes)
            ]

        for prefix in ['T_', 'B_', 'S_']:
            cols = [f"{prefix}AQI"] + [col for col in feature_cols if col.startswith(prefix)]
            df[cols] = df[cols].ffill().bfill()

        if df.isnull().any().any():
            raise ValueError("数据仍包含缺失值")

        return df, feature_cols
    except Exception as e:
        print(f"数据加载失败: {str(e)}")
        raise


def build_city_graph():
    distance_matrix = np.array([[0, 120, 320], [120, 0, 280], [320, 280, 0]])
    gdp_ratio = np.array([[1.0, 0.43, 0.20], [2.33, 1.0, 0.47], [5.0, 2.15, 1.0]])
    adj_matrix = 0.7 * (1 / (distance_matrix + 1e-6)) + 0.3 * gdp_ratio
    adj_matrix /= adj_matrix.max()
    adj_matrix[adj_matrix < 0.4] = 0
    return torch.tensor(adj_matrix, dtype=torch.float)


class AQIPredictor(nn.Module):
    def __init__(self, input_dim, hidden_dim=128, dropout_rate=0.3):
        super().__init__()
        self.conv1 = GCNConv(input_dim, hidden_dim)
        self.conv2 = GCNConv(hidden_dim, hidden_dim)
        self.conv3 = GCNConv(hidden_dim, 1)
        self.dropout = nn.Dropout(dropout_rate)

    def forward(self, data):
        x, edge_index, edge_weight = data.x, data.edge_index, data.edge_weight
        x = torch.relu(self.conv1(x, edge_index, edge_weight))
        x = self.dropout(x)
        x = torch.relu(self.conv2(x, edge_index, edge_weight))
        x = self.dropout(x)
        x = self.conv3(x, edge_index, edge_weight)
        return x


def genetic_algorithm(fitness_func, param_ranges, pop_size=5, generations=3):
    # 确保种群大小是偶数
    if pop_size % 2 != 0:
        pop_size += 1
        print(f"警告：种群大小调整为偶数 {pop_size}")
    population = []
    for _ in range(pop_size):
        individual = [
            random.randint(*param_ranges['hidden_dim']),
            random.uniform(*param_ranges['dropout_rate']),
            random.uniform(*param_ranges['lr'])
        ]
        population.append(individual)

    best_individual = None
    best_fitness = -float('inf')

    for _ in range(generations):
        fitness_scores = []
        for individual in population:
            fitness = fitness_func(individual)
            fitness_scores.append(fitness)
            if fitness > best_fitness:
                best_fitness = fitness
                best_individual = individual

        selected = []
        total = sum(fitness_scores)
        if total == 0:
            selected = population.copy()
        else:
            probs = [f / total for f in fitness_scores]
            selected = random.choices(population, weights=probs, k=pop_size)

            # 交叉操作修改部分
            new_population = []
            for i in range(0, len(selected) - 1, 2):  # 确保不越界
                p1, p2 = selected[i], selected[i + 1]
                crossover_point = random.randint(1, 2)
                c1 = p1[:crossover_point] + p2[crossover_point:]
                c2 = p2[:crossover_point] + p1[crossover_point:]
                new_population.extend([c1, c2])

        for ind in new_population:
            if random.random() < 0.2:
                idx = random.randint(0, 2)
                if idx == 0:
                    ind[idx] = random.randint(*param_ranges['hidden_dim'])
                else:
                    ind[idx] = random.uniform(*param_ranges[['dropout_rate', 'lr'][idx - 1]])

        population = new_population

    return best_individual, best_fitness


if __name__ == "__main__":
    DATA_PATH = "./data/jingjinji.xlsx"
    SAVE_DIR = "GA_gcn_AQI_models"
    OUTPUT_DIR = "GA_gcn_AQI_output"
    os.makedirs(SAVE_DIR, exist_ok=True)
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    DEVICE = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

    df, feature_cols = load_and_preprocess(DATA_PATH)
    train_size = int(len(df) * 0.85)

    # 修改此处数据划分方式
    train_df = df.iloc[:train_size].copy()  # 添加copy()
    test_df = df.iloc[train_size:].copy()  # 添加copy()

    cities = ['T', 'B', 'S']
    city_names = {'T': '天津', 'B': '北京', 'S': '石家庄'}
    adj_matrix = build_city_graph()
    edge_index = adj_matrix.nonzero().t().contiguous().to(DEVICE)
    edge_weight = adj_matrix[adj_matrix.nonzero().t()[0], adj_matrix.nonzero().t()[1]].to(DEVICE)
    test_metrics_list = []

    for city in cities:
        target_col = f'{city}_AQI'
        city_train = train_df.iloc[:int(0.8 * len(train_df))]
        city_valid = train_df.iloc[int(0.8 * len(train_df)):]

        scaler = StandardScaler()
        train_features = scaler.fit_transform(city_train[feature_cols])
        valid_features = scaler.transform(city_valid[feature_cols])

        x_train = torch.tensor(train_features, dtype=torch.float32).to(DEVICE)
        y_train = torch.tensor(city_train[target_col].values.reshape(-1, 1), dtype=torch.float32).to(DEVICE)
        x_valid = torch.tensor(valid_features, dtype=torch.float32).to(DEVICE)
        y_valid = torch.tensor(city_valid[target_col].values.reshape(-1, 1), dtype=torch.float32).to(DEVICE)


        def fitness_func(params):
            hidden_dim, dropout_rate, lr = params
            model = AQIPredictor(len(feature_cols), int(hidden_dim), dropout_rate).to(DEVICE)
            optimizer = optim.Adam(model.parameters(), lr=lr)
            criterion = nn.MSELoss()
            for _ in range(50):
                model.train()
                optimizer.zero_grad()
                pred = model(Data(x=x_train, edge_index=edge_index, edge_weight=edge_weight, y=y_train))
                loss = criterion(pred, y_train)
                loss.backward()
                optimizer.step()
            with torch.no_grad():
                pred = model(Data(x=x_valid, edge_index=edge_index, edge_weight=edge_weight))
                return -criterion(pred, y_valid).item()


        best_params, _ = genetic_algorithm(
            fitness_func,
            {'hidden_dim': (64, 256), 'dropout_rate': (0.1, 0.5), 'lr': (0.001, 0.1)},
            pop_size=5, generations=3
        )

        model = AQIPredictor(len(feature_cols), int(best_params[0]), best_params[1]).to(DEVICE)
        optimizer = optim.Adam(model.parameters(), lr=best_params[2])
        criterion = nn.MSELoss()

        for epoch in range(300):
            model.train()
            optimizer.zero_grad()
            pred = model(Data(x=x_train, edge_index=edge_index, edge_weight=edge_weight, y=y_train))
            loss = criterion(pred, y_train)
            loss.backward()
            optimizer.step()

        torch.save(model.state_dict(), f"{SAVE_DIR}/best_model_{city}.pth")

        test_features = scaler.transform(test_df[feature_cols])
        test_x = torch.tensor(test_features, dtype=torch.float32).to(DEVICE)
        test_data = Data(x=test_x, edge_index=edge_index, edge_weight=edge_weight)
        # 在测试预测部分修改如下：
        model.eval()
        with torch.no_grad():
            test_pred = model(test_data).detach().cpu().numpy().flatten()
        test_df[f'{city}_预测值'] = test_pred

        test_metrics = {
            '城市': city_names[city],
            'MSE': mean_squared_error(test_df[target_col], test_pred),
            'RMSE': np.sqrt(mean_squared_error(test_df[target_col], test_pred)),
                            'MAE': mean_absolute_error(test_df[target_col], test_pred),
        'R2': r2_score(test_df[target_col], test_pred),
        'MAPE':np.mean(np.abs(((test_df[target_col] - test_pred) / ((test_df[target_col] + 1e-6))))) * 100,
        'SMAPE': smape(test_df[target_col], test_pred)
        }
        test_metrics_list.append(test_metrics)

        test_results_df = pd.DataFrame(test_metrics_list)
        test_results_df.to_csv(f"{OUTPUT_DIR}/测试集评估结果.csv", index=False)
        test_df.to_csv(f"{OUTPUT_DIR}/预测结果.csv", index=False)

    # 创建可视化输出目录
    VIS_DIR = os.path.join(OUTPUT_DIR, "visualization")
    os.makedirs(VIS_DIR, exist_ok=True)

    # 1. 各城市预测对比曲线图
    # ======================
    for city in cities:
        city_name = city_names[city]
        target_col = f'{city}_AQI'
        pred_col = f'{city}_预测值'

        plt.figure(figsize=(15, 6))
        plt.plot(test_df['date'], test_df[target_col],
                 label=f'真实AQI', linewidth=2, color='#1f77b4')
        plt.plot(test_df['date'], test_df[pred_col],
                 '--', label=f'预测AQI', linewidth=2, color='#ff7f0e', alpha=0.8)

        # 设置图表属性
        plt.title(f'{city_name} AQI预测对比', fontsize=14)
        plt.xlabel('日期', fontsize=12)
        plt.ylabel('AQI指数', fontsize=12)

        # 设置日期刻度
        ax = plt.gca()
        ax.xaxis.set_major_locator(mdates.MonthLocator(interval=2))
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
        plt.xticks(rotation=45)

        # 设置y轴范围
        y_min = max(0, min(test_df[target_col].min(), test_df[pred_col].min())) * 0.95
        y_max = max(test_df[target_col].max(), test_df[pred_col].max()) * 1.05
        plt.ylim(y_min, y_max)

        plt.grid(True, linestyle='--', alpha=0.6)
        plt.legend(fontsize=12)
        plt.tight_layout()
        plt.savefig(f"{VIS_DIR}/{city_name}_AQI预测对比曲线图.png", dpi=300, bbox_inches='tight')
        plt.close()

    # 2. 各城市残差图
    # ======================
    for city in cities:
        city_name = city_names[city]
        target_col = f'{city}_AQI'
        pred_col = f'{city}_预测值'

        residuals = test_df[target_col] - test_df[pred_col]

        plt.figure(figsize=(15, 6))
        plt.scatter(test_df['date'], residuals,
                    alpha=0.6, color='#2ca02c', label='残差分布')
        plt.axhline(y=0, color='r', linestyle='--', linewidth=1, label='零误差线')

        # 设置图表属性
        plt.title(f'{city_name} AQI预测残差', fontsize=14)
        plt.xlabel('日期', fontsize=12)
        plt.ylabel('残差 (真实值 - 预测值)', fontsize=12)

        # 设置日期刻度
        ax = plt.gca()
        ax.xaxis.set_major_locator(mdates.MonthLocator(interval=2))
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
        plt.xticks(rotation=45)

        plt.grid(True, linestyle='--', alpha=0.6)
        plt.legend(fontsize=12)
        plt.tight_layout()
        plt.savefig(f"{VIS_DIR}/{city_name}_AQI残差图.png", dpi=300, bbox_inches='tight')
        plt.close()

    # 3. 三城市对比曲线图
    # ======================
    plt.figure(figsize=(18, 9))
    colors = {'天津': '#1f77b4', '北京': '#ff7f0e', '石家庄': '#2ca02c'}

    for city in cities:
        city_name = city_names[city]
        target_col = f'{city}_AQI'
        pred_col = f'{city}_预测值'

        # 绘制真实值
        plt.plot(test_df['date'], test_df[target_col],
                 color=colors[city_name], linewidth=1.5,
                 linestyle='-', label=f'{city_name}真实值')

        # 绘制预测值
        plt.plot(test_df['date'], test_df[pred_col],
                 color=colors[city_name], linewidth=1.5,
                 linestyle='--', label=f'{city_name}预测值')

    # 设置图表属性
    plt.title('京津冀三城市AQI预测对比', fontsize=16)
    plt.xlabel('日期', fontsize=14)
    plt.ylabel('AQI指数', fontsize=14)

    # 设置日期刻度
    ax = plt.gca()
    ax.xaxis.set_major_locator(mdates.MonthLocator(interval=2))
    ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
    plt.xticks(rotation=45)

    plt.grid(True, linestyle='--', alpha=0.6)
    plt.legend(ncol=3, fontsize=12, loc='upper right')
    plt.tight_layout()
    plt.savefig(f"{VIS_DIR}/三城市AQI预测综合对比图.png", dpi=300, bbox_inches='tight')
    plt.close()

    # 4. 生成对比表格
    # ======================
    # 选择展示的时间范围（最后30天）
    latest_dates = test_df['date'].sort_values(ascending=False).head(30).sort_values()
    comparison_df = test_df[test_df['date'].isin(latest_dates)].copy()

    # 创建对比表格
    table_data = []
    for _, row in comparison_df.iterrows():
        record = {
            '日期': row['date'].strftime('%Y-%m-%d'),
        }
        for city in cities:
            city_name = city_names[city]
            target_col = f'{city}_AQI'
            pred_col = f'{city}_预测值'

            record[f'{city_name}真实值'] = round(row[target_col], 1)
            record[f'{city_name}预测值'] = round(row[pred_col], 1)
            record[f'{city_name}残差'] = round(row[target_col] - row[pred_col], 1)

        table_data.append(record)

    # 转换为DataFrame并保存
    comparison_table = pd.DataFrame(table_data)
    comparison_table.to_excel(f"{OUTPUT_DIR}/真实预测对比表格.xlsx", index=False)

    # 生成表格可视化图片
    plt.figure(figsize=(18, 12))
    ax = plt.subplot(111, frame_on=False)
    ax.xaxis.set_visible(False)
    ax.yaxis.set_visible(False)

    # 创建表格对象
    table = pd.plotting.table(
        ax,
        comparison_table.round(1).head(10),  # 展示前10天数据
        loc='center',
        cellLoc='center',
        colWidths=[0.1] * len(comparison_table.columns))

    # 调整表格样式
    table.auto_set_font_size(False)
    table.set_fontsize(12)
    table.scale(1.2, 1.2)

    plt.savefig(f"{VIS_DIR}/对比表格示例.png", dpi=300, bbox_inches='tight')
    plt.close()